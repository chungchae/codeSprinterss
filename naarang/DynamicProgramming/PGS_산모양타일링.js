function solution(n, tops) {
  let answer = 0;
  let dp = [0, 0, 0, 0];

  // 첫번째 top의 여부에 따라 초기화
  if (tops[0] === 0) dp = [1, 0, 1, 1];
  else dp = [1, 1, 1, 1];

  for (let i = 1; i < n; i++) {
    let newDp = [0, 0, 0, 0];

    newDp[0] = (dp[0] + dp[1] + dp[2] + dp[3]) % 10007;
    if (tops[i] === 1) {
      newDp[1] = (dp[0] + dp[1] + dp[2] + dp[3]) % 10007;
    }
    newDp[2] = (dp[0] + dp[1] + dp[2]) % 10007;
    newDp[3] = (dp[0] + dp[1] + dp[2] + dp[3]) % 10007;

    dp = [...newDp];
  }

  answer = dp.reduce((prev, num) => prev + num, 0);

  return answer % 10007;
}

// 마지막에 10007로 나누지 말고 미리 10007로 나누었어야 했다!

/*

4개의 삼각형이 하나의 큰 삼각형을 이룬다고 생각했을 때 중심 삼각형을 기준으로 3개의 변에 연결된 삼각형들 중 하나를 선택해서 색칠한다고 생각하면 쉬웠다!

차례대로 색칠해나가면서 앞에서 계산한 경우에 누적하면 되겠다고 생각해서 DP로 풀었다

dp[0] : 앞에서 아무것도 색칠 안한 경우
dp[1] : 앞에서 윗변의 삼각형을 선택해 색칠한 경우
dp[2] : 앞에서 왼쪽 변의 삼각형을 선택해 색칠한 경우
dp[3] : 앞에서 오른쪽 변의 삼각형을 선택해 색칠한 경우

이때 앞서서 오른쪽변의 삼각형을 선택해서 색칠했다면 뒤에서는 곂치는 칸을 중복해서 계산하면 안됐다!

```js

newDp[2] = (dp[0] + dp[1] + dp[2]) % 10007;

```

그리고 윗변의 삼각형을 tops 배열에 따라 있을수도 없을수도 있기 때문에 고려해야 한다

```js

if (tops[i] === 1) {
  newDp[1] = (dp[0] + dp[1] + dp[2] + dp[3]) % 10007;
}

```

*/
